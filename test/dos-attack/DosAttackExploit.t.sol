// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {VulnerableDistributor} from "src/dos-attack/VulnerableDistributor.sol";
import {SecureDistributor} from "src/dos-attack/SecureDistributor.sol";

/// @title MaliciousReceiver - Contract that can be used for DOS attacks
/// @notice Simulates various attack vectors against distribution contracts
contract MaliciousReceiver {
    bool public shouldRevert;
    bool public shouldConsumeGas;
    uint256 public gasToConsume;
    address public owner;

    constructor(bool _shouldRevert, bool _shouldConsumeGas, uint256 _gasToConsume) {
        shouldRevert = _shouldRevert;
        shouldConsumeGas = _shouldConsumeGas;
        gasToConsume = _gasToConsume;
        owner = msg.sender;
    }

    /// @notice Toggle revert behavior
    function toggleRevert() external {
        require(msg.sender == owner, "Only owner");
        shouldRevert = !shouldRevert;
    }

    /// @notice Set gas consumption behavior
    function setGasConsumption(bool _shouldConsume, uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        shouldConsumeGas = _shouldConsume;
        gasToConsume = _amount;
    }

    /// @notice Receive function that can attack distribution
    receive() external payable {
        if (shouldRevert) {
            revert("MaliciousReceiver: reverting transfer");
        }

        if (shouldConsumeGas) {
            // Consume specified amount of gas
            uint256 gasLeft = gasleft();
            uint256 gasTarget = gasLeft > gasToConsume ? gasLeft - gasToConsume : 0;

            while (gasleft() > gasTarget) {
                // Consume gas by performing expensive operations
                keccak256(abi.encode(block.timestamp, block.prevrandao, gasLeft));
            }
        }
    }

    /// @notice Drain received ether
    function drain() external {
        require(msg.sender == owner, "Only owner");
        payable(owner).transfer(address(this).balance);
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

/// @title GasGriefingContract - Contract designed to grief gas usage
contract GasGriefingContract {
    mapping(uint256 => bytes32) public dataStore;
    uint256 public counter;

    receive() external payable {
        // Perform gas-intensive operations
        for (uint256 i = 0; i < 100; i++) {
            dataStore[counter + i] = keccak256(abi.encode(block.timestamp, i, msg.sender));
        }
        counter += 100;

        // Revert after consuming gas
        revert("Gas griefing attack");
    }
}

/// @title DOS Attack Exploit Test Suite
/// @notice Comprehensive tests demonstrating DOS attack vulnerabilities and protections
contract DosAttackExploitTest is Test {
    VulnerableDistributor public vulnerableDistributor;
    SecureDistributor public secureDistributor;
    MaliciousReceiver public maliciousReceiver;
    GasGriefingContract public gasGriefer;

    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");
    address public attacker = makeAddr("attacker");

    address[] public normalUsers;
    address[] public largeUserList;

    function setUp() public {
        vm.startPrank(owner);
        vulnerableDistributor = new VulnerableDistributor();
        secureDistributor = new SecureDistributor();
        vm.stopPrank();

        // Deploy malicious contracts
        vm.prank(attacker);
        maliciousReceiver = new MaliciousReceiver(true, false, 0); // Starts reverting

        gasGriefer = new GasGriefingContract();

        // Setup normal users array
        normalUsers = [user1, user2, user3];

        // Create large user list for DOS testing (100 users)
        for (uint256 i = 0; i < 100; i++) {
            largeUserList.push(makeAddr(string(abi.encodePacked("user", i))));
        }

        // Give users ether
        vm.deal(owner, 100 ether);
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(user3, 10 ether);
        vm.deal(attacker, 10 ether);
    }

    /// @notice Test normal distribution functionality
    function test_NormalDistribution() public {
        vm.startPrank(owner);

        // Add participants
        for (uint256 i = 0; i < normalUsers.length; i++) {
            vulnerableDistributor.addParticipant(normalUsers[i]);
        }

        // Deposit rewards
        vulnerableDistributor.depositRewards{value: 3 ether}();

        // Distribute rewards
        vulnerableDistributor.distributeRewards();

        // Check balances
        for (uint256 i = 0; i < normalUsers.length; i++) {
            assertEq(vulnerableDistributor.getParticipantBalance(normalUsers[i]), 1 ether);
        }

        vm.stopPrank();

        // Users claim rewards
        vm.prank(user1);
        vulnerableDistributor.claimReward();
        assertEq(user1.balance, 11 ether);
    }

    /// @notice Test DOS attack via large batch operations
    function test_DosAttackLargeBatch() public {
        vm.startPrank(owner);

        console.log("=== DOS Attack: Large Batch Operations ===");

        // Demonstrate gas consumption increases linearly with batch size
        uint256 gasStart = gasleft();

        // Add normal sized batch first
        address[] memory smallBatch = new address[](10);
        for (uint256 i = 0; i < 10; i++) {
            smallBatch[i] = makeAddr(string(abi.encodePacked("smallBatch", i)));
        }
        vulnerableDistributor.batchAddParticipants(smallBatch);

        uint256 smallBatchGas = gasStart - gasleft();
        console.log("Small batch (10 users) gas:", smallBatchGas);

        // Try larger batch to show gas scaling issue
        gasStart = gasleft();
        vulnerableDistributor.batchAddParticipants(largeUserList); // 100 users
        uint256 largeBatchGas = gasStart - gasleft();

        console.log("Large batch (100 users) gas:", largeBatchGas);
        assertTrue(largeBatchGas > smallBatchGas * 5, "Large batch should use significantly more gas");

        vm.stopPrank();
    }

    /// @notice Test DOS attack via unbounded distribution loop
    function test_DosAttackUnboundedDistribution() public {
        vm.startPrank(owner);

        console.log("=== DOS Attack: Unbounded Distribution Loop ===");

        // Add participants and measure gas consumption
        for (uint256 i = 0; i < 30; i++) {
            // Use smaller number that works
            vulnerableDistributor.addParticipant(largeUserList[i]);
        }

        vulnerableDistributor.depositRewards{value: 10 ether}();

        console.log("Participants added:", vulnerableDistributor.getParticipantCount());

        // Measure gas consumption for distribution
        uint256 gasStart = gasleft();
        vulnerableDistributor.distributeRewards();
        uint256 gasUsed = gasStart - gasleft();

        console.log("Gas used for distribution:", gasUsed);
        console.log("Gas per participant:", gasUsed / vulnerableDistributor.getParticipantCount());

        // The test demonstrates that gas usage scales with participant count
        assertTrue(gasUsed > 500000, "Distribution should use significant gas with many participants");

        vm.stopPrank();
    }

    /// @notice Test DOS attack via malicious recipient in push pattern
    function test_DosAttackMaliciousRecipient() public {
        vm.startPrank(owner);

        console.log("=== DOS Attack: Malicious Recipient Blocking Distribution ===");

        // Add normal participants
        vulnerableDistributor.addParticipant(user1);
        vulnerableDistributor.addParticipant(user2);

        // Add malicious receiver
        vulnerableDistributor.addParticipant(address(maliciousReceiver));

        vulnerableDistributor.depositRewards{value: 3 ether}();

        console.log("Attempting push distribution with malicious receiver...");

        // This should fail when it hits the malicious receiver
        vm.expectRevert("Transfer failed");
        vulnerableDistributor.pushRewardsToAll();

        console.log("Push distribution blocked by malicious receiver");

        vm.stopPrank();
    }

    /// @notice Test gas griefing attack
    function test_GasGriefingAttack() public {
        vm.startPrank(owner);

        console.log("=== Gas Griefing Attack ===");

        // Add gas griefer as participant
        vulnerableDistributor.addParticipant(address(gasGriefer));
        vulnerableDistributor.addParticipant(user1);

        vulnerableDistributor.depositRewards{value: 2 ether}();

        console.log("Attempting distribution to gas griefer...");

        uint256 gasStart = gasleft();

        // This will consume gas and then revert
        vm.expectRevert();
        vulnerableDistributor.pushRewardsToAll();

        uint256 gasUsed = gasStart - gasleft();
        console.log("Gas consumed by griefing attack:", gasUsed);

        vm.stopPrank();
    }

    /// @notice Test DOS via expensive view functions
    function test_DosAttackExpensiveViewFunctions() public {
        vm.startPrank(owner);

        console.log("=== DOS Attack: Expensive View Functions ===");

        // Add many participants
        for (uint256 i = 0; i < 30; i++) {
            // Reduced for testing
            vulnerableDistributor.addParticipant(largeUserList[i]);
            vulnerableDistributor.balances(largeUserList[i]); // Set some balance
        }

        console.log("Testing expensive getAllParticipants()...");

        // This should work but consume a lot of gas
        uint256 gasStart = gasleft();
        address[] memory allParticipants = vulnerableDistributor.getAllParticipants();
        uint256 gasUsed = gasStart - gasleft();

        console.log("Gas used for getAllParticipants():", gasUsed);
        console.log("Participants returned:", allParticipants.length);

        console.log("Testing expensive getTotalOwed()...");

        // This will consume gas proportional to participant count
        gasStart = gasleft();
        vulnerableDistributor.getTotalOwed();
        gasUsed = gasStart - gasleft();

        console.log("Gas used for getTotalOwed():", gasUsed);

        vm.stopPrank();
    }

    /// @notice Test secure distributor prevents DOS attacks
    function test_SecureDistributorPrevention() public {
        vm.startPrank(owner);

        console.log("=== Secure Distributor: DOS Prevention ===");

        // Test batch size limit
        vm.expectRevert();
        secureDistributor.batchAddParticipants(largeUserList);

        console.log("Large batch addition blocked by size limit");

        // Add participants in smaller batches
        uint256 batchSize = 50; // Under MAX_BATCH_SIZE
        for (uint256 i = 0; i < batchSize; i++) {
            secureDistributor.addParticipant(largeUserList[i]);
        }

        console.log("Participants added:", secureDistributor.getParticipantCount());

        // Deposit rewards
        secureDistributor.depositRewards{value: 10 ether}();

        // Start paginated distribution
        secureDistributor.startDistribution();

        console.log("Starting paginated distribution...");

        // Continue distribution in batches
        bool completed = false;
        uint256 batchCount = 0;

        while (!completed && batchCount < 10) {
            // Prevent infinite loop in test
            completed = secureDistributor.continueDistribution();
            batchCount++;
            console.log("Distribution batch", batchCount, "completed");
        }

        assertTrue(completed, "Distribution should complete");
        console.log("Distribution completed in", batchCount, "batches");

        vm.stopPrank();

        // Users can claim rewards individually (pull pattern)
        vm.prank(largeUserList[0]);
        secureDistributor.claimReward();

        console.log("User successfully claimed reward");
    }

    /// @notice Test secure distributor pagination
    function test_SecureDistributorPagination() public {
        vm.startPrank(owner);

        // Add some participants
        for (uint256 i = 0; i < 25; i++) {
            secureDistributor.addParticipant(largeUserList[i]);
        }

        // Test paginated participant retrieval
        (address[] memory participants, uint256 total) = secureDistributor.getParticipants(0, 10);

        assertEq(participants.length, 10);
        assertEq(total, 25);

        // Test second page
        (address[] memory participants2,) = secureDistributor.getParticipants(10, 10);
        assertEq(participants2.length, 10);

        // Test final page
        (address[] memory participants3,) = secureDistributor.getParticipants(20, 10);
        assertEq(participants3.length, 5); // Only 5 remaining

        console.log("Pagination working correctly");

        vm.stopPrank();
    }

    /// @notice Test secure distributor with malicious participants
    function test_SecureDistributorWithMaliciousParticipants() public {
        vm.startPrank(owner);

        console.log("=== Secure Distributor: Handling Malicious Participants ===");

        // Add normal and malicious participants
        secureDistributor.addParticipant(user1);
        secureDistributor.addParticipant(address(maliciousReceiver));
        secureDistributor.addParticipant(user2);

        secureDistributor.depositRewards{value: 3 ether}();

        // Distribution using pull pattern - malicious receiver can't block others
        secureDistributor.startDistribution();
        secureDistributor.continueDistribution(); // Should complete in one batch

        vm.stopPrank();

        // Normal users can claim successfully
        uint256 balanceBefore = user1.balance;
        vm.prank(user1);
        secureDistributor.claimReward();
        assertTrue(user1.balance > balanceBefore, "User1 should receive reward");

        // Malicious receiver's reward is available but can't block others
        (uint256 maliciousBalance,) = secureDistributor.getParticipantInfo(address(maliciousReceiver));
        assertTrue(maliciousBalance > 0, "Malicious receiver should have balance");

        // If malicious receiver tries to claim and fails, it doesn't affect others
        vm.prank(address(maliciousReceiver));
        vm.expectRevert("Transfer failed");
        secureDistributor.claimReward();

        console.log("Malicious participant couldn't block other users");
    }

    /// @notice Test distribution cancellation
    function test_DistributionCancellation() public {
        vm.startPrank(owner);

        // Setup distribution
        secureDistributor.addParticipant(user1);
        secureDistributor.addParticipant(user2);
        secureDistributor.depositRewards{value: 2 ether}();

        // Start distribution
        secureDistributor.startDistribution();

        // Cancel distribution
        secureDistributor.cancelDistribution();

        // Check that rewards are refunded
        (, uint256 totalRewardsAvailable,) = secureDistributor.getFinancialSummary();
        assertEq(totalRewardsAvailable, 2 ether, "Rewards should be refunded");

        console.log("Distribution successfully cancelled and refunded");

        vm.stopPrank();
    }

    /// @notice Test gas estimation
    function test_GasEstimation() public {
        vm.startPrank(owner);

        // Add participants
        for (uint256 i = 0; i < 30; i++) {
            secureDistributor.addParticipant(largeUserList[i]);
        }

        (uint256 estimatedGas, uint256 batchesNeeded) = secureDistributor.estimateDistributionGas();

        console.log("Estimated gas for distribution:", estimatedGas);
        console.log("Batches needed:", batchesNeeded);

        assertTrue(estimatedGas > 0, "Should provide gas estimate");
        assertTrue(batchesNeeded > 0, "Should need at least one batch");

        vm.stopPrank();
    }

    /// @notice Test emergency withdrawal
    function test_EmergencyWithdrawal() public {
        vm.startPrank(owner);

        secureDistributor.depositRewards{value: 5 ether}();

        uint256 balanceBefore = owner.balance;
        secureDistributor.emergencyWithdraw();

        assertEq(owner.balance, balanceBefore + 5 ether, "Owner should receive all funds");

        vm.stopPrank();
    }

    /// @notice Test batch claim functionality
    function test_BatchClaim() public {
        vm.startPrank(owner);

        // Setup participants with rewards
        address[] memory claimUsers = new address[](3);
        claimUsers[0] = user1;
        claimUsers[1] = user2;
        claimUsers[2] = user3;

        for (uint256 i = 0; i < claimUsers.length; i++) {
            secureDistributor.addParticipant(claimUsers[i]);
        }

        secureDistributor.depositRewards{value: 3 ether}();
        secureDistributor.startDistribution();
        secureDistributor.continueDistribution();

        // Batch claim for users
        uint256[] memory balancesBefore = new uint256[](claimUsers.length);
        for (uint256 i = 0; i < claimUsers.length; i++) {
            balancesBefore[i] = claimUsers[i].balance;
        }

        secureDistributor.batchClaim(claimUsers);

        // Verify all users received rewards
        for (uint256 i = 0; i < claimUsers.length; i++) {
            assertTrue(claimUsers[i].balance > balancesBefore[i], "User should receive reward");
        }

        console.log("Batch claim successful for all users");

        vm.stopPrank();
    }

    /// @notice Fuzz test for participant management
    function testFuzz_ParticipantManagement(uint8 participantCount) public {
        vm.assume(participantCount > 0 && participantCount <= 50);

        vm.startPrank(owner);

        address[] memory testUsers = new address[](participantCount);
        for (uint256 i = 0; i < participantCount; i++) {
            testUsers[i] = makeAddr(string(abi.encodePacked("fuzzUser", i)));
            secureDistributor.addParticipant(testUsers[i]);
        }

        assertEq(secureDistributor.getParticipantCount(), participantCount);

        // Test distribution with fuzzed participant count
        if (participantCount > 0) {
            secureDistributor.depositRewards{value: uint256(participantCount) * 1 ether}();
            secureDistributor.startDistribution();

            bool completed = false;
            uint256 maxBatches = (participantCount / 20) + 1;

            for (uint256 batch = 0; batch < maxBatches && !completed; batch++) {
                completed = secureDistributor.continueDistribution();
            }

            assertTrue(completed, "Distribution should complete");
        }

        vm.stopPrank();
    }

    /// @notice Test gas usage comparison
    function test_GasUsageComparison() public {
        vm.startPrank(owner);

        // Setup both distributors with same participants
        for (uint256 i = 0; i < 10; i++) {
            vulnerableDistributor.addParticipant(largeUserList[i]);
            secureDistributor.addParticipant(largeUserList[i]);
        }

        vulnerableDistributor.depositRewards{value: 10 ether}();
        secureDistributor.depositRewards{value: 10 ether}();

        // Test vulnerable distributor gas usage
        uint256 gasStart = gasleft();
        vulnerableDistributor.distributeRewards();
        uint256 vulnerableGas = gasStart - gasleft();

        // Test secure distributor gas usage
        secureDistributor.startDistribution();
        gasStart = gasleft();
        secureDistributor.continueDistribution();
        uint256 secureGas = gasStart - gasleft();

        console.log("Vulnerable distributor gas:", vulnerableGas);
        console.log("Secure distributor gas (first batch):", secureGas);

        // Secure distributor may use slightly more gas due to safety checks but prevents DOS
        // The key is that it doesn't scale unboundedly like the vulnerable version
        assertTrue(secureGas > 0, "Secure distributor should complete successfully");
        assertTrue(vulnerableGas > 0, "Vulnerable distributor should complete successfully");

        // The important difference is that secure distributor is bounded and won't fail with large datasets
        assertTrue(secureGas < 1000000, "Secure distributor should use bounded gas per batch");

        vm.stopPrank();
    }
}
