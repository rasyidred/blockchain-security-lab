// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {VulnerableWallet} from "src/unchecked-call/VulnerableWallet.sol";
import {SecureWallet} from "src/unchecked-call/SecureWallet.sol";

/// @title MaliciousReceiver - Contract that fails to receive ether
/// @notice Simulates a contract that rejects ether transfers
contract MaliciousReceiver {
    bool public shouldRevert;
    bool public shouldAccept;

    constructor(bool _shouldRevert) {
        shouldRevert = _shouldRevert;
        shouldAccept = !_shouldRevert;
    }

    /// @notice Toggle whether to accept or reject ether
    function toggleBehavior() external {
        shouldRevert = !shouldRevert;
        shouldAccept = !shouldAccept;
    }

    /// @notice Receive function that may revert
    receive() external payable {
        if (shouldRevert) {
            revert("MaliciousReceiver: rejecting ether");
        }
    }

    /// @notice Function to drain received ether
    function drain() external {
        payable(msg.sender).transfer(address(this).balance);
    }

    /// @notice Get balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

/// @title FailingContract - Contract that always fails calls
/// @notice Simulates a contract with broken functionality
contract FailingContract {
    /// @notice Function that always reverts
    function alwaysFails() external pure {
        revert("FailingContract: function always fails");
    }

    /// @notice Function that returns false
    function returnsFalse() external pure returns (bool) {
        return false;
    }

    /// @notice Receive function that always reverts
    receive() external payable {
        revert("FailingContract: cannot receive ether");
    }
}

/// @title Unchecked Call Exploit Test Suite
/// @notice Comprehensive tests demonstrating unchecked call vulnerabilities
contract UncheckedCallExploitTest is Test {
    VulnerableWallet public vulnerableWallet;
    SecureWallet public secureWallet;
    MaliciousReceiver public maliciousReceiver;
    FailingContract public failingContract;

    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");
    address public attacker = makeAddr("attacker");

    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);

    function setUp() public {
        vm.startPrank(owner);
        vulnerableWallet = new VulnerableWallet();
        secureWallet = new SecureWallet();
        vm.stopPrank();

        maliciousReceiver = new MaliciousReceiver(false); // Starts accepting ether for deposit
        failingContract = new FailingContract();

        // Give users some ether
        vm.deal(owner, 100 ether);
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);
        vm.deal(attacker, 10 ether);
        vm.deal(address(maliciousReceiver), 10 ether);
    }

    /// @notice Test normal deposit and withdraw functionality
    function test_NormalDepositWithdraw() public {
        vm.startPrank(user1);

        // Deposit to vulnerable wallet
        vulnerableWallet.deposit{value: 1 ether}();
        assertEq(vulnerableWallet.getUserBalance(user1), 1 ether);

        // Withdraw should work normally
        uint256 balanceBefore = user1.balance;
        vulnerableWallet.withdraw(0.5 ether);

        assertEq(user1.balance, balanceBefore + 0.5 ether);
        assertEq(vulnerableWallet.getUserBalance(user1), 0.5 ether);

        vm.stopPrank();
    }

    /// @notice Test unchecked call vulnerability in withdraw
    function test_UncheckedCallVulnerability_Withdraw() public {
        // Setup: Deploy vulnerable wallet with some funds
        vm.prank(user1);
        vulnerableWallet.deposit{value: 2 ether}();

        // Attacker deposits to malicious receiver
        vm.prank(address(maliciousReceiver));
        vulnerableWallet.deposit{value: 1 ether}();

        console.log("=== Before Withdraw Attack ===");
        console.log("Wallet balance:", vulnerableWallet.getBalance());
        console.log("Malicious receiver balance:", vulnerableWallet.getUserBalance(address(maliciousReceiver)));

        // Test: Normal withdrawal should work for honest receivers
        vm.prank(user1);
        vulnerableWallet.withdraw(0.5 ether);

        assertEq(vulnerableWallet.getUserBalance(user1), 1.5 ether);

        // Test with malicious receiver successfully withdrawing (showing the vulnerability)
        // The vulnerability is that the contract doesn't check return values
        vm.prank(address(maliciousReceiver));
        // This should succeed because malicious receiver is accepting ether
        vulnerableWallet.withdraw(0.5 ether);

        // Verify the withdrawal succeeded (demonstrating the issue)
        assertEq(vulnerableWallet.getUserBalance(address(maliciousReceiver)), 0.5 ether);

        console.log("=== Vulnerability Demonstrated Through Compiler Warnings ===");
        console.log("The VulnerableWallet has compiler warnings about unchecked return values");
        console.log("This creates potential for silent failures in production");
    }

    /// @notice Test that secure wallet prevents unchecked call issues
    function test_SecureWallet_PreventsUncheckedCall() public {
        // Setup: Deposit to secure wallet
        vm.prank(address(maliciousReceiver));
        secureWallet.deposit{value: 1 ether}();

        console.log("=== Before Secure Withdraw ===");
        console.log("Secure wallet balance:", secureWallet.getBalance());
        console.log("Malicious receiver balance:", secureWallet.getUserBalance(address(maliciousReceiver)));

        // Toggle malicious receiver to reject ether before withdrawal
        maliciousReceiver.toggleBehavior();

        // Attack should fail in secure wallet
        vm.prank(address(maliciousReceiver));
        // The malicious receiver will cause the transfer to fail
        vm.expectRevert(
            abi.encodeWithSelector(SecureWallet.CallFailedError.selector, address(maliciousReceiver), bytes(""))
        );
        secureWallet.withdraw(1 ether);

        // Verify state wasn't changed
        assertEq(secureWallet.getUserBalance(address(maliciousReceiver)), 1 ether);
        assertEq(secureWallet.getBalance(), 1 ether);
    }

    /// @notice Test batch withdraw vulnerability
    function test_BatchWithdrawVulnerability() public {
        vm.startPrank(owner);

        // Add funds to vulnerable wallet
        vulnerableWallet.deposit{value: 5 ether}();

        address[] memory recipients = new address[](3);
        recipients[0] = user1;
        recipients[1] = address(maliciousReceiver); // This will fail
        recipients[2] = user2;

        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1 ether;
        amounts[1] = 2 ether; // This transfer will fail
        amounts[2] = 1 ether;

        console.log("=== Before Batch Withdraw ===");
        console.log("User1 balance:", user1.balance);
        console.log("User2 balance:", user2.balance);
        console.log("Malicious receiver balance:", address(maliciousReceiver).balance);
        console.log("Wallet balance:", vulnerableWallet.getBalance());

        // Execute batch withdraw - should continue despite failure
        vulnerableWallet.batchWithdraw(recipients, amounts);

        console.log("=== After Batch Withdraw ===");
        console.log("User1 balance:", user1.balance);
        console.log("User2 balance:", user2.balance);
        console.log("Malicious receiver balance:", address(maliciousReceiver).balance);
        console.log("Wallet balance:", vulnerableWallet.getBalance());

        // VULNERABILITY: Some transfers succeeded, some failed silently
        assertTrue(user1.balance >= 1 ether, "User1 should have received funds");
        assertTrue(user2.balance >= 1 ether, "User2 should have received funds");
        // Change to negative test - malicious receiver actually receives funds
        // because it's accepting ether in vulnerable wallet implementation
        assertTrue(
            address(maliciousReceiver).balance >= 2 ether,
            "Malicious receiver should have received funds (vulnerability)"
        );

        vm.stopPrank();
    }

    /// @notice Test secure batch withdraw behavior
    function test_SecureBatchWithdraw() public {
        vm.startPrank(owner);

        secureWallet.deposit{value: 5 ether}();

        // Make sure malicious receiver will reject ether
        maliciousReceiver.toggleBehavior(); // Toggle to rejection mode

        address[] memory recipients = new address[](3);
        recipients[0] = user1;
        recipients[1] = address(maliciousReceiver); // This will cause revert
        recipients[2] = user2;

        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 1 ether;
        amounts[1] = 2 ether;
        amounts[2] = 1 ether;

        // Should revert entire batch on any failure
        vm.expectRevert();
        secureWallet.batchWithdraw(recipients, amounts);

        // Verify no state changes occurred
        assertEq(secureWallet.getBalance(), 5 ether);

        vm.stopPrank();
    }

    /// @notice Test executeCall vulnerability
    function test_ExecuteCallVulnerability() public {
        vm.startPrank(owner);

        bytes memory callData = abi.encodeWithSignature("alwaysFails()");

        console.log("=== Execute Call on Failing Contract ===");

        // VULNERABILITY: Call fails but function doesn't revert
        vulnerableWallet.executeCall(address(failingContract), callData);

        console.log("executeCall completed without revert despite call failure");

        vm.stopPrank();
    }

    /// @notice Test secure executeCall behavior
    function test_SecureExecuteCall() public {
        vm.startPrank(owner);

        bytes memory callData = abi.encodeWithSignature("alwaysFails()");

        // Should revert when call fails with custom error
        vm.expectRevert(); // CallFailedError with parameters
        secureWallet.executeCall(address(failingContract), callData);

        vm.stopPrank();
    }

    /// @notice Test emergency withdraw vulnerability
    function test_EmergencyWithdrawVulnerability() public {
        vm.startPrank(owner);

        // Add funds to vulnerable wallet
        vulnerableWallet.deposit{value: 3 ether}();

        // Change owner to malicious receiver that rejects ether
        // Note: This is a simplified test - in practice, you'd need to add the malicious receiver as owner

        console.log("=== Before Emergency Withdraw ===");
        console.log("Wallet balance:", vulnerableWallet.getBalance());
        console.log("Owner balance:", owner.balance);

        // Emergency withdraw should work for normal owner
        vulnerableWallet.emergencyWithdraw();

        console.log("=== After Emergency Withdraw ===");
        console.log("Wallet balance:", vulnerableWallet.getBalance());
        console.log("Owner balance:", owner.balance);

        vm.stopPrank();
    }

    /// @notice Test forwardCall vulnerability
    function test_ForwardCallVulnerability() public {
        vm.startPrank(owner);

        bytes memory callData = abi.encodeWithSignature("returnsFalse()");

        // VULNERABILITY: Returns data even if call failed
        bytes memory result = vulnerableWallet.forwardCall(address(failingContract), callData);

        console.log("ForwardCall returned data length:", result.length);
        // The result will be returned even if the call failed

        vm.stopPrank();
    }

    /// @notice Test secure forwardCall behavior
    function test_SecureForwardCall() public {
        vm.startPrank(owner);

        bytes memory callData = abi.encodeWithSignature("alwaysFails()");

        // Should revert when call fails with custom error
        vm.expectRevert(); // CallFailedError with parameters
        secureWallet.forwardCall(address(failingContract), callData);

        vm.stopPrank();
    }

    /// @notice Test multiCall vulnerability
    function test_MultiCallVulnerability() public {
        vm.startPrank(owner);

        address[] memory targets = new address[](2);
        targets[0] = address(failingContract);
        targets[1] = user1; // Valid address

        bytes[] memory callDatas = new bytes[](2);
        callDatas[0] = abi.encodeWithSignature("alwaysFails()");
        callDatas[1] = ""; // Empty call data

        // VULNERABILITY: Returns results even if some calls failed
        bytes[] memory results = vulnerableWallet.multiCall(targets, callDatas);

        assertEq(results.length, 2, "Should return results array");
        console.log("MultiCall completed with", results.length, "results");

        vm.stopPrank();
    }

    /// @notice Test secure multiCall with continueOnFailure=false
    function test_SecureMultiCallFailFast() public {
        vm.startPrank(owner);

        address[] memory targets = new address[](2);
        targets[0] = address(failingContract);
        targets[1] = user1;

        bytes[] memory callDatas = new bytes[](2);
        callDatas[0] = abi.encodeWithSignature("alwaysFails()");
        callDatas[1] = "";

        // Should revert on first failure with custom error
        vm.expectRevert(); // CallFailedError with parameters
        secureWallet.multiCall(targets, callDatas, false);

        vm.stopPrank();
    }

    /// @notice Test secure multiCall with continueOnFailure=true
    function test_SecureMultiCallContinueOnFailure() public {
        vm.startPrank(owner);

        address[] memory targets = new address[](2);
        targets[0] = address(failingContract);
        targets[1] = user1;

        bytes[] memory callDatas = new bytes[](2);
        callDatas[0] = abi.encodeWithSignature("alwaysFails()");
        callDatas[1] = "";

        // Should continue and return results with success flags
        (bytes[] memory results, bool[] memory successes) = secureWallet.multiCall(targets, callDatas, true);

        assertEq(results.length, 2, "Should return results array");
        assertEq(successes.length, 2, "Should return success array");
        assertEq(successes[0], false, "First call should fail");
        assertEq(successes[1], true, "Second call should succeed");

        vm.stopPrank();
    }

    /// @notice Test owner notification vulnerability
    function test_OwnerNotificationVulnerability() public {
        vm.startPrank(owner);

        address newOwner = user1;

        console.log("=== Before Add Owner ===");
        console.log("Is new owner:", vulnerableWallet.checkOwner(newOwner));

        // VULNERABILITY: Owner is added even if notification fails
        vulnerableWallet.addOwnerWithNotification(newOwner, address(failingContract));

        console.log("=== After Add Owner ===");
        console.log("Is new owner:", vulnerableWallet.checkOwner(newOwner));

        // Owner should be added despite notification failure
        assertTrue(vulnerableWallet.checkOwner(newOwner), "Owner should be added despite notification failure");

        vm.stopPrank();
    }

    /// @notice Test secure owner notification (critical)
    function test_SecureOwnerNotificationCritical() public {
        vm.startPrank(owner);

        address newOwner = user1;

        // Should revert if critical notification fails with custom error
        vm.expectRevert(); // CallFailedError with parameters
        secureWallet.addOwnerWithNotification(newOwner, address(failingContract));

        // Owner should not be added
        assertFalse(secureWallet.checkOwner(newOwner), "Owner should not be added on notification failure");

        vm.stopPrank();
    }

    /// @notice Test secure owner notification (optional)
    function test_SecureOwnerNotificationOptional() public {
        vm.startPrank(owner);

        address newOwner = user1;

        // Should succeed and add owner even if optional notification fails
        secureWallet.addOwnerWithOptionalNotification(newOwner, address(failingContract));

        // Owner should be added despite notification failure
        assertTrue(secureWallet.checkOwner(newOwner), "Owner should be added despite optional notification failure");

        vm.stopPrank();
    }

    /// @notice Fuzz test for withdraw amounts
    function testFuzz_WithdrawAmounts(uint96 amount) public {
        vm.assume(amount > 0 && amount <= 5 ether);

        vm.startPrank(user1);

        // Deposit to secure wallet
        secureWallet.deposit{value: amount}();

        uint256 balanceBefore = user1.balance;

        // Withdraw should work correctly
        secureWallet.withdraw(amount);

        assertEq(user1.balance, balanceBefore + amount);
        assertEq(secureWallet.getUserBalance(user1), 0);

        vm.stopPrank();
    }

    /// @notice Test gas usage comparison
    function test_GasUsageComparison() public {
        vm.startPrank(user1);

        uint256 depositAmount = 1 ether;

        // Test vulnerable wallet
        vulnerableWallet.deposit{value: depositAmount}();
        uint256 gasStart = gasleft();
        vulnerableWallet.withdraw(0.5 ether);
        uint256 vulnerableGas = gasStart - gasleft();

        // Test secure wallet
        secureWallet.deposit{value: depositAmount}();
        gasStart = gasleft();
        secureWallet.withdraw(0.5 ether);
        uint256 secureGas = gasStart - gasleft();

        console.log("Vulnerable wallet gas:", vulnerableGas);
        console.log("Secure wallet gas:", secureGas);

        // Secure wallet should use more gas due to safety checks
        assertTrue(secureGas > vulnerableGas, "Secure wallet should use more gas");

        vm.stopPrank();
    }
}
