// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {VulnerableAuction} from "src/front-running/VulnerableAuction.sol";
import {SecureAuction} from "src/front-running/SecureAuction.sol";

/// @title FrontRunnerBot - Simulates a front-running MEV bot
/// @notice Demonstrates how attackers can front-run auction bids
contract FrontRunnerBot {
    VulnerableAuction public auction;
    address public owner;

    constructor(address _auction) {
        auction = VulnerableAuction(_auction);
        owner = msg.sender;
    }

    /// @notice Front-run a bid by bidding slightly higher
    /// @param targetBid The bid amount to front-run
    function frontRunBid(uint256 targetBid) external payable {
        require(msg.sender == owner, "Only owner");

        // Front-run by bidding 1% higher
        uint256 frontRunAmount = targetBid + (targetBid / 100);
        require(msg.value >= frontRunAmount, "Insufficient ether");

        auction.bid{value: frontRunAmount}();

        // Return excess ether
        if (msg.value > frontRunAmount) {
            payable(msg.sender).transfer(msg.value - frontRunAmount);
        }
    }

    /// @notice Sandwich attack: front-run and back-run
    /// @param victimBid The victim's bid amount
    function sandwichAttack(uint256 victimBid) external payable {
        require(msg.sender == owner, "Only owner");

        // Front-run with slightly higher bid
        uint256 frontBid = victimBid + 0.001 ether;
        auction.bid{value: frontBid}();

        // Note: In real MEV, the back-run would happen after victim's transaction
        // This is a simplified demonstration
    }

    /// @notice Monitor and exploit quick bid function
    function exploitQuickBid() external payable {
        (, uint256 currentHighest) = auction.getCurrentHighestBid();
        uint256 quickBidAmount = currentHighest + 0.01 ether;

        // Front-run the quick bid
        auction.bid{value: quickBidAmount + 0.001 ether}();
    }

    /// @notice Drain function
    function drain() external {
        require(msg.sender == owner, "Only owner");
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}

/// @title Front-Running Exploit Test Suite
/// @notice Comprehensive tests demonstrating front-running vulnerabilities and protections
contract FrontRunningExploitTest is Test {
    VulnerableAuction public vulnerableAuction;
    SecureAuction public secureAuction;
    FrontRunnerBot public bot;

    address public seller = makeAddr("seller");
    address public bidder1 = makeAddr("bidder1");
    address public bidder2 = makeAddr("bidder2");
    address public bidder3 = makeAddr("bidder3");
    address public frontRunner = makeAddr("frontRunner");

    uint256 constant AUCTION_DURATION = 1 hours;
    uint256 constant COMMIT_DURATION = 30 minutes;
    uint256 constant REVEAL_DURATION = 20 minutes;

    function setUp() public {
        // Deploy vulnerable auction
        vm.prank(seller);
        vulnerableAuction = new VulnerableAuction(AUCTION_DURATION);

        // Deploy secure auction
        vm.prank(seller);
        secureAuction = new SecureAuction(COMMIT_DURATION, REVEAL_DURATION, 1 ether);

        // Deploy front-running bot
        vm.prank(frontRunner);
        bot = new FrontRunnerBot(address(vulnerableAuction));

        // Give bidders ether
        vm.deal(bidder1, 10 ether);
        vm.deal(bidder2, 10 ether);
        vm.deal(bidder3, 10 ether);
        vm.deal(frontRunner, 20 ether);
        vm.deal(address(bot), 20 ether);
    }

    /// @notice Test normal bidding flow
    function test_NormalBiddingFlow() public {
        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        (address highestBidder, uint256 highestBid) = vulnerableAuction.getCurrentHighestBid();
        assertEq(highestBidder, bidder1);
        assertEq(highestBid, 1 ether);

        vm.prank(bidder2);
        vulnerableAuction.bid{value: 2 ether}();

        (highestBidder, highestBid) = vulnerableAuction.getCurrentHighestBid();
        assertEq(highestBidder, bidder2);
        assertEq(highestBid, 2 ether);
    }

    /// @notice Test front-running attack demonstration
    function test_FrontRunningAttack() public {
        console.log("=== Front-Running Attack Demonstration ===");

        // Initial bid
        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        console.log("Initial bid by bidder1: 1 ETH");

        // Simulate bidder2 planning to bid 3 ether
        uint256 victimBid = 3 ether;

        // Front-runner sees this in mempool and front-runs
        vm.prank(frontRunner);
        bot.frontRunBid{value: 4 ether}(victimBid);

        (address highestBidder, uint256 highestBid) = vulnerableAuction.getCurrentHighestBid();
        console.log("After front-run - Highest bidder:", highestBidder);
        console.log("After front-run - Highest bid:", highestBid);

        // Victim's transaction now fails or succeeds with higher price
        vm.prank(bidder2);
        vm.expectRevert("Bid not high enough");
        vulnerableAuction.bid{value: victimBid}();

        // Front-runner successfully won by front-running
        assertEq(highestBidder, address(bot));
        assertTrue(highestBid > victimBid);
    }

    /// @notice Test sandwich attack
    function test_SandwichAttack() public {
        console.log("=== Sandwich Attack Demonstration ===");

        // Setup initial state
        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        console.log("Initial bid: 1 ETH");

        uint256 victimBid = 2.5 ether;

        // Front-run: Bot bids slightly higher than victim's intended bid
        vm.prank(frontRunner);
        bot.sandwichAttack{value: 5 ether}(victimBid);

        (address highestBidder, uint256 highestBid) = vulnerableAuction.getCurrentHighestBid();
        console.log("After front-run - Highest bid:", highestBid);

        // Victim's bid is now insufficient
        vm.prank(bidder2);
        vm.expectRevert("Bid not high enough");
        vulnerableAuction.bid{value: victimBid}();

        // Bot maintains winning position
        assertEq(highestBidder, address(bot));
    }

    /// @notice Test quick bid exploitation
    function test_QuickBidExploitation() public {
        // Setup auction with some bids
        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        console.log("=== Quick Bid Exploitation ===");
        (, uint256 currentBid) = vulnerableAuction.getCurrentHighestBid();
        console.log("Current highest bid:", currentBid);

        // Front-runner exploits predictable quick bid mechanism
        vm.prank(frontRunner);
        bot.exploitQuickBid{value: 5 ether}();

        (, uint256 newHighest) = vulnerableAuction.getCurrentHighestBid();
        console.log("After exploitation - Highest bid:", newHighest);

        // Now when victim tries to use quick bid, they get outbid
        vm.prank(bidder2);
        vm.expectRevert("Bid too low");
        vulnerableAuction.quickBid{value: currentBid + 0.01 ether}();
    }

    /// @notice Test batch bid front-running
    function test_BatchBidFrontRunning() public {
        console.log("=== Batch Bid Front-Running ===");

        uint256[] memory bidAmounts = new uint256[](3);
        bidAmounts[0] = 1 ether;
        bidAmounts[1] = 1.5 ether;
        bidAmounts[2] = 2 ether;

        uint256 totalValue = 4.5 ether;

        // Front-runner sees batch bid transaction and front-runs with highest amount
        vm.prank(frontRunner);
        vulnerableAuction.bid{value: 2.1 ether}();

        // Victim's batch bid becomes less effective
        vm.prank(bidder1);
        vulnerableAuction.batchBid{value: totalValue}(bidAmounts);

        (address highestBidder,) = vulnerableAuction.getCurrentHighestBid();

        // Front-runner maintains lead
        assertEq(highestBidder, frontRunner);
    }

    /// @notice Test snipe bid exploitation
    function test_SnipeBidExploitation() public {
        // Fast-forward to near end of auction
        vm.warp(block.timestamp + AUCTION_DURATION - 30);

        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        // Fast-forward to after auction end
        vm.warp(block.timestamp + 35);

        console.log("=== Snipe Bid Exploitation ===");

        // Attacker uses snipe bid to extend auction and win
        vm.prank(frontRunner);
        vulnerableAuction.snipeBid{value: 2 ether}();

        (address highestBidder, uint256 highestBid) = vulnerableAuction.getCurrentHighestBid();
        console.log("Snipe bidder:", highestBidder);
        console.log("Snipe bid amount:", highestBid);

        assertEq(highestBidder, frontRunner);
        assertEq(highestBid, 2 ether);

        // Check that auction was extended
        assertTrue(vulnerableAuction.isActive(), "Auction should be extended");
    }

    /// @notice Test secure auction prevents front-running
    function test_SecureAuctionPrevention() public {
        console.log("=== Secure Auction Front-Running Prevention ===");

        // Commit phase - bids are hidden
        uint256 bidAmount1 = 2 ether;
        uint256 nonce1 = 12345;
        bytes32 commitment1 = secureAuction.generateCommitment(bidAmount1, nonce1, bidder1);

        vm.prank(bidder1);
        secureAuction.commitBid{value: 0.1 ether}(commitment1);

        uint256 bidAmount2 = 3 ether;
        uint256 nonce2 = 67890;
        bytes32 commitment2 = secureAuction.generateCommitment(bidAmount2, nonce2, bidder2);

        vm.prank(bidder2);
        secureAuction.commitBid{value: 0.1 ether}(commitment2);

        console.log("Commitments placed - bid amounts hidden");

        // Try to front-run during commit phase - not possible to see actual bids
        uint256 bidAmount3 = 1.5 ether;
        uint256 nonce3 = 11111;
        bytes32 commitment3 = secureAuction.generateCommitment(bidAmount3, nonce3, frontRunner);

        vm.prank(frontRunner);
        secureAuction.commitBid{value: 0.1 ether}(commitment3);

        // Advance to reveal phase
        vm.warp(block.timestamp + COMMIT_DURATION + 1);
        vm.prank(seller);
        secureAuction.advancePhase();

        // Reveal phase - order doesn't matter due to commit-reveal scheme
        vm.prank(bidder1);
        secureAuction.revealBid{value: bidAmount1}(bidAmount1, nonce1);

        vm.prank(bidder2);
        secureAuction.revealBid{value: bidAmount2}(bidAmount2, nonce2);

        vm.prank(frontRunner);
        secureAuction.revealBid{value: bidAmount3}(bidAmount3, nonce3);

        (, address highestBidder, uint256 highestBid,,) = secureAuction.getAuctionState();

        console.log("Final winner:", highestBidder);
        console.log("Final bid:", highestBid);

        // Highest legitimate bid wins, not the front-runner
        assertEq(highestBidder, bidder2);
        assertEq(highestBid, bidAmount2);
    }

    /// @notice Test commit-reveal mechanism integrity
    function test_CommitRevealIntegrity() public {
        uint256 bidAmount = 5 ether;
        uint256 nonce = 99999;
        bytes32 correctCommitment = secureAuction.generateCommitment(bidAmount, nonce, bidder1);

        vm.prank(bidder1);
        secureAuction.commitBid{value: 0.5 ether}(correctCommitment);

        // Advance to reveal phase
        vm.warp(block.timestamp + COMMIT_DURATION + 1);
        vm.prank(seller);
        secureAuction.advancePhase();

        // Try to reveal with wrong nonce - should fail
        vm.prank(bidder1);
        vm.expectRevert();
        secureAuction.revealBid{value: bidAmount}(bidAmount, nonce + 1);

        // Try to reveal with wrong bid amount - should fail
        vm.prank(bidder1);
        vm.expectRevert();
        secureAuction.revealBid{value: bidAmount}(bidAmount + 1 ether, nonce);

        // Correct reveal should work
        vm.prank(bidder1);
        secureAuction.revealBid{value: bidAmount}(bidAmount, nonce);

        (, address highestBidder, uint256 highestBid,,) = secureAuction.getAuctionState();
        assertEq(highestBidder, bidder1);
        assertEq(highestBid, bidAmount);
    }

    /// @notice Test MEV resistance in secure auction
    function test_MEVResistance() public {
        console.log("=== MEV Resistance Test ===");

        // Multiple bidders commit without revealing bid amounts
        uint256[] memory bidAmounts = new uint256[](3);
        uint256[] memory nonces = new uint256[](3);
        address[] memory bidders = new address[](3);

        bidAmounts[0] = 2 ether;
        bidAmounts[1] = 4 ether; // Highest bid
        bidAmounts[2] = 3 ether;

        nonces[0] = 1111;
        nonces[1] = 2222;
        nonces[2] = 3333;

        bidders[0] = bidder1;
        bidders[1] = bidder2;
        bidders[2] = bidder3;

        // Commit phase - MEV bot cannot see actual bid values
        for (uint256 i = 0; i < 3; i++) {
            bytes32 commitment = secureAuction.generateCommitment(bidAmounts[i], nonces[i], bidders[i]);
            vm.prank(bidders[i]);
            secureAuction.commitBid{value: 0.2 ether}(commitment);
        }

        console.log("All commitments placed - MEV bot cannot determine bid amounts");

        // Advance to reveal phase
        vm.warp(block.timestamp + COMMIT_DURATION + 1);
        vm.prank(seller);
        secureAuction.advancePhase();

        // Reveal in different order - MEV protection ensures fair outcome
        vm.prank(bidders[2]);
        secureAuction.revealBid{value: bidAmounts[2]}(bidAmounts[2], nonces[2]);

        vm.prank(bidders[0]);
        secureAuction.revealBid{value: bidAmounts[0]}(bidAmounts[0], nonces[0]);

        vm.prank(bidders[1]);
        secureAuction.revealBid{value: bidAmounts[1]}(bidAmounts[1], nonces[1]);

        (, address winner, uint256 winningBid,,) = secureAuction.getAuctionState();

        console.log("Winner:", winner);
        console.log("Winning bid:", winningBid);

        // Highest bid should win regardless of reveal order
        assertEq(winner, bidder2);
        assertEq(winningBid, 4 ether);
    }

    /// @notice Test gas usage comparison
    function test_GasUsageComparison() public {
        // Test vulnerable auction gas usage
        vm.prank(bidder1);
        uint256 gasStart = gasleft();
        vulnerableAuction.bid{value: 1 ether}();
        uint256 vulnerableGas = gasStart - gasleft();

        // Test secure auction commit gas usage
        bytes32 commitment = secureAuction.generateCommitment(1 ether, 12345, bidder1);
        vm.prank(bidder1);
        gasStart = gasleft();
        secureAuction.commitBid{value: 0.1 ether}(commitment);
        uint256 secureCommitGas = gasStart - gasleft();

        console.log("Vulnerable auction bid gas:", vulnerableGas);
        console.log("Secure auction commit gas:", secureCommitGas);

        // Secure auction uses more gas but provides security
        assertTrue(secureCommitGas > vulnerableGas, "Secure auction should use more gas");
    }

    /// @notice Fuzz test for commitment generation
    function testFuzz_CommitmentGeneration(uint256 bidAmount, uint256 nonce, address bidder) public {
        vm.assume(bidAmount > 0 && bidAmount <= 100 ether);
        vm.assume(bidder != address(0));

        bytes32 commitment1 = secureAuction.generateCommitment(bidAmount, nonce, bidder);
        bytes32 commitment2 = secureAuction.generateCommitment(bidAmount, nonce, bidder);

        // Same inputs should generate same commitment
        assertEq(commitment1, commitment2);

        // Different nonce should generate different commitment
        if (nonce < type(uint256).max) {
            bytes32 commitment3 = secureAuction.generateCommitment(bidAmount, nonce + 1, bidder);
            assertTrue(commitment1 != commitment3);
        }
    }

    /// @notice Test withdrawal mechanisms
    function test_WithdrawalMechanisms() public {
        // Test vulnerable auction withdrawal
        vm.prank(bidder1);
        vulnerableAuction.bid{value: 1 ether}();

        vm.prank(bidder2);
        vulnerableAuction.bid{value: 2 ether}();

        // Bidder1 should be able to withdraw overbid amount
        uint256 pendingReturn = vulnerableAuction.getPendingReturn(bidder1);
        assertEq(pendingReturn, 1 ether);

        uint256 balanceBefore = bidder1.balance;
        vm.prank(bidder1);
        vulnerableAuction.withdraw();

        assertEq(bidder1.balance, balanceBefore + 1 ether);
    }
}
